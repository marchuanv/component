const factory = require('../factory.js');
window.component = {};
function ClientMessageBus({ httpClientRequestMessageBus, httpClientResponseMessageBus, messageConverter }) {
    Object.defineProperty(this, 'publish', { configurable: false, writable: false, value: async ({ message }) => {
        await httpClientRequestMessageBus.publish(messageConverter.convertMessageToHttpRequestMessage({ message }));
    }});
    Object.defineProperty(this, 'subscribe', { configurable: false, writable: false, value: ({ callback }) => {
        httpClientResponseMessageBus.subscribe({ callback: async ({ httpResponseMessage }) => {
            await callback(messageConverter.convertHttpResponseMessageToMessage({ httpResponseMessage }));
        }});
    }});
}
function createClientMessageBus({scopeId}) {
    let container = factory.getContainer({ scopeId, type: ClientMessageBus, variableName:'clientMessageBus', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: ClientMessageBus, variableName:'clientMessageBus', singleton: false });
        container.config({});
            container.config(createHttpClientResponseMessageBus({scopeId}));
container.config(createHttpClientRequestMessageBus({scopeId}));
container.config(createMessageConverter({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createClientMessageBus = createClientMessageBus;
function Component({ scopeId, clientMessageBus, serverMessageBus, userSessions, packageJson }) {
    const { createHttpServerMessageBus } = require('./factory/httpservermessagebus.factory.js');
    const { createHttpServerMessageBusManager } = require('./factory/httpservermessagebusmanager.factory.js');
    const { createHttpClientMessageBus } = require('./factory/httpclientmessagebus.factory.js');
    const { createHttpClientMessageBusManager } = require('./factory/httpclientmessagebusmanager.factory.js');
    const { createMessage } = require('./factory/message.factory');
    const { senderHost, senderPort, recipientHost, recipientPort, userId, timeout, isServerComponent } = packageJson;
    Object.defineProperty(this, 'initialise', { configurable: false, writable: false, value: async ({ secret }) => {
        const { userSecurity } = userSessions.ensureSession({ userId });
        userSecurity.register({ secret });
        const { token } = userSecurity.authenticate({ secret });
        if (isServerComponent) {
            createHttpServerMessageBus({ scopeId, timeout, senderHost, senderPort });
            createHttpServerMessageBusManager({ scopeId });
            Object.defineProperty(this, 'receive', { configurable: false, writable: false, value: async ({ callback }) => {
                await serverMessageBus.subscribe({ callback });
            }});
            Object.defineProperty(this, 'send', { configurable: false, writable: false, value: async (data) => {
                await serverMessageBus.publish(createMessage({ 
                    scopeId: utils.generateGUID(),
                    messageStatusCode: 0, Id: null, data,
                    recipientHost, recipientPort, metadata: {}, token, senderHost, senderPort 
                }));
            }});
        } else {
            createHttpClientMessageBus({ scopeId, timeout });
            createHttpClientMessageBusManager({ scopeId });
            Object.defineProperty(this, 'receive', { configurable: false, writable: false, value: async ({ callback }) => {
                await clientMessageBus.subscribe({ callback });
            }});
            Object.defineProperty(this, 'send', { configurable: false, writable: false, value: async (data) => {
                await clientMessageBus.publish(createMessage({ 
                    scopeId: utils.generateGUID(),
                    messageStatusCode: 2, Id: null, data,
                    recipientHost, recipientPort, metadata: {}, token, senderHost, senderPort 
                }));
            }});
        }
    }});
}
function createComponent({scopeId,packageJson}) {
    let container = factory.getContainer({ scopeId, type: Component, variableName:'component', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: Component, variableName:'component', singleton: false });
        container.config({packageJson});
            container.config(createUserSessions({scopeId}));
container.config(createServerMessageBus({scopeId}));
container.config(createClientMessageBus({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createComponent = createComponent;
function ContentType({ name }) {
    const valueIndex = Object.values(types).findIndex(x => x === name);
    const keyIndex = Object.keys(types).findIndex(x => x === name);
    const _name = keyIndex > 0 ? name: valueIndex > 0 ? Object.keys(types)[valueIndex] : 'unknown';
    Object.defineProperty(this, 'name', { configurable: false, writable: false, value: _name });
    Object.defineProperty(this, 'description', { configurable: false, writable: false, value: types[_name] });
}
function createContentType({scopeId,name}) {
    let container = factory.getContainer({ scopeId, type: ContentType, variableName:'contentType', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: ContentType, variableName:'contentType', singleton: false });
        container.config({name});
            
    }
    container.ensureInstance();
    return container.references;
}
window.createContentType = createContentType;
function Logger() {
    let logs = {};
    let isLogging = false;
    Object.defineProperty(this, 'log', { configurable: false, writable: false, value: ({ date, context, text }) => {
        const promise = new Promise((resolve) => {
            const intervalId = setInterval(() => {
                if (!isLogging) {
                    isLogging = true;
                    if (!logs[context]) {
                        logs[context] = [];
                    }
                    logs[context].push({ date, text });
                    resolve();
                    logs[context] = logs[context].sort((log1, log2) => {
                        return new Date(log1.date) - new Date(log2.date);
                    });
                    let log = logs[context].shift();
                    while(log) {
                        const { date, text } = log;
                        console.log(`${date.toISOString()}: ${context}, ${text}`);
                        log = logs[context].shift();
                    }
                    clearInterval(intervalId);
                    isLogging = false;
                }
            }, 1000);
        });
        return promise;
    }});
}
function createLogger({scopeId}) {
    let container = factory.getContainer({ scopeId, type: Logger, variableName:'logger', singleton: true });
    if (!container) {
        container = factory.createContainer({ scopeId, type: Logger, variableName:'logger', singleton: true });
        container.config({});
            
    }
    container.ensureInstance();
    return container.references;
}
window.createLogger = createLogger;
function Message({ scopeId, Id, messageContent, messageContentMetadata, messageMetadata, messageStatus }) {
    const { createRecipientAddress } = require("./factory/recipientaddress.factory");
    const { createSenderAddress } = require("./factory/senderaddress.factory");
    const messageId = Id || utils.generateGUID();
    Object.defineProperty(this, 'getId', { configurable: false, writable: false, value: () => {
        return messageId;
    }});
    Object.defineProperty(this, 'getSenderAddress', { configurable: false, writable: false, value: () => {
        const { senderhost, senderport  } = messageMetadata;
        return createSenderAddress({ scopeId, senderHost: senderhost, senderPort: senderport });
    }});
    Object.defineProperty(this, 'getRecipientAddress', { configurable: false, writable: false, value: () => {
        const { recipienthost, recipientport  } = messageMetadata;
        return createRecipientAddress({ scopeId, recipientHost: recipienthost, recipientPort: recipientport });
    }});
    Object.defineProperty(this, 'getEncryptedContent', { configurable: false, writable: false, value: () => {
        return messageContent.encryptedData;
    }});
    Object.defineProperty(this, 'getDecryptedContent', { configurable: false, writable: false, value: () => {
        return messageContent.decryptedData;
    }});
    Object.defineProperty(this, 'getMessageMetadata', { configurable: false, writable: false, value: () => {
        return messageMetadata;
    }});
    Object.defineProperty(this, 'getContentMetadata', { configurable: false, writable: false, value: () => {
        return messageContentMetadata;
    }});
    Object.defineProperty(this, 'getMessageStatus', { configurable: false, writable: false, value: () => {
        return messageStatus.root();
    }});
}
function createMessage({scopeId,messageStatusCode,Id,data,recipientHost,recipientPort,metadata,token,senderHost,senderPort}) {
    let container = factory.getContainer({ scopeId, type: Message, variableName:'message', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: Message, variableName:'message', singleton: false });
        container.config({messageStatusCode,Id,data,recipientHost,recipientPort,metadata,token,senderHost,senderPort});
            container.config(createMessageMetadata({scopeId,recipientHost,recipientPort,metadata,token,senderHost,senderPort}));
container.config(createMessageContentMetadata({scopeId,data}));
container.config(createMessageContent({scopeId,data,recipientHost,recipientPort,metadata,token,senderHost,senderPort}));
container.config(createMessageStatus({scopeId,messageStatusCode}));
    }
    container.ensureInstance();
    return container.references;
}
window.createMessage = createMessage;
function MessageContent({ data, userSessions, messageMetadata, messageContentMetadata }) {

    const { token } = messageMetadata;
    const { userId } = utils.getJSONObject(utils.base64ToString(token));
    const { userSecurity } = userSessions.ensureSession({ userId });

    let decryptedData = null;
    let encryptedData = null;

    if (userSecurity.isAuthorised({ token })) {
        const { contentType, isEncrypted } = messageContentMetadata;
        if (isEncrypted && contentType.name === 'base64Text') {
            decryptedData = userSecurity.decryptJSONToObject({ encryptedJsonStr: data.replace('Encrypted:', '') });
            encryptedData = data;
        } else {
            let object = null;  
            if (typeof data === 'string') {
                if (contentType.name === 'txt') {
                    object = { text: data };
                }
            }
            encryptedData = userSecurity.encryptObjectToJSON({ object });
            decryptedData = userSecurity.decryptJSONToObject({ encryptedJsonStr: encryptedData });
            encryptedData = `Encrypted:${encryptedData}`;
            messageContentMetadata.setContentType({ name: 'txt' })
            messageContentMetadata.setContentLength({ length: Buffer.byteLength(encryptedData) });
        }
    } else {
        decryptedData = `unable to decrypt message content, '${userId}' user is not authorised.`;
        encryptedData = `unable to encrypt message content, '${userId}' user is not authorised.`;
    }
    Object.defineProperty(this, 'encryptedData', { configurable: false, writable: false, value: encryptedData });
    Object.defineProperty(this, 'decryptedData', { configurable: false, writable: false, value: decryptedData });
}
function createMessageContent({scopeId,data,recipientHost,recipientPort,metadata,token,senderHost,senderPort}) {
    let container = factory.getContainer({ scopeId, type: MessageContent, variableName:'messageContent', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: MessageContent, variableName:'messageContent', singleton: false });
        container.config({data,recipientHost,recipientPort,metadata,token,senderHost,senderPort});
            container.config(createMessageMetadata({scopeId,recipientHost,recipientPort,metadata,token,senderHost,senderPort}));
container.config(createUserSessions({scopeId}));
container.config(createMessageContentMetadata({scopeId,data}));
    }
    container.ensureInstance();
    return container.references;
}
window.createMessageContent = createMessageContent;
function MessageContentMetadata({ scopeId, data }) {
    const { createContentType } = require('./factory/contenttype.factory.js');
    let isEncrypted = false;
    let name = null;
    let _data = utils.getJSONObject(data) || data;
    if (typeof _data === 'object') {
        name = 'json';
        _data = utils.getJSONString(_data);
    } else if (typeof _data === 'string') {
        name = 'txt';
        isEncrypted = data.startsWith('Encrypted:');
        if (utils.isBase64String(data.replace('Encrypted:',''))) {
           name = 'base64Text';
        }
    }
    let { contentType } = createContentType({ scopeId, name });
    let contentLength = Buffer.byteLength(_data);
    Object.defineProperty(this, 'contentType', { configurable: false, get: () => contentType });
    Object.defineProperty(this, 'contentLength', { configurable: false, get: () => contentLength });
    Object.defineProperty(this, 'isEncrypted', { configurable: false, writable: false, value: isEncrypted });
    Object.defineProperty(this, 'setContentLength', { configurable: false, writable: false, value: ({ length }) => contentLength = length });
    Object.defineProperty(this, 'setContentType', { configurable: false, writable: false, value: ({ name }) => contentType = createContentType({ scopeId, name }) });
}
function createMessageContentMetadata({scopeId,data}) {
    let container = factory.getContainer({ scopeId, type: MessageContentMetadata, variableName:'messageContentMetadata', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: MessageContentMetadata, variableName:'messageContentMetadata', singleton: false });
        container.config({data});
            
    }
    container.ensureInstance();
    return container.references;
}
window.createMessageContentMetadata = createMessageContentMetadata;
function MessageConverter() {
    
    const { createHttpResponseMessage } = require('./factory/httpresponsemessage.factory');
    const { createHttpRequestMessage } = require('./factory/httprequestmessage.factory');
    const { createMessage } = require('./factory/message.factory');

    Object.defineProperty(this, 'convertMessageToHttpRequestMessage', { configurable: false, writable: false, value: ({ message }) => {
        const Id = message.getId();
        const encryptedContent = message.getEncryptedContent();
        const { senderHost, senderPort } = message.getSenderAddress();
        const { recipientHost, recipientPort } = message.getRecipientAddress();
        const metadata = message.getMessageMetadata();
        const { token } = metadata;
        const { code } = message.getMessageStatus();
        const messageStatusCode = code;
        return createHttpRequestMessage({ 
            scopeId: utils.generateGUID(),
            messageStatusCode, Id,  data: encryptedContent, recipientHost,
            recipientPort, metadata, token, senderHost, senderPort
        });
    }});
    Object.defineProperty(this, 'convertMessageToHttpResponseMessage', { configurable: false, writable: false, value: ({ message }) => {
        const { code } = message.getMessageStatus();
        const messageStatusCode = code;
        const Id = message.getId();
        const data = message.getEncryptedContent();
        const { recipientHost, recipientPort } = message.getRecipientAddress();
        const metadata = message.getMessageMetadata();
        const { token } = metadata;
        const { senderHost, senderPort } = message.getSenderAddress();
        return createHttpResponseMessage({ 
            scopeId: utils.generateGUID(),
            messageStatusCode, Id, data,
            recipientHost, recipientPort, metadata,
            token, senderHost, senderPort
        });
    }});
    Object.defineProperty(this, 'convertHttpRequestMessageToMessage', { configurable: false, writable: false, value: ({ httpRequestMessage }) => {
        const { code } = httpRequestMessage.getMessageStatus();
        const messageStatusCode = code;
        const Id = httpRequestMessage.getId();
        const data = httpRequestMessage.getEncryptedContent();
        const { recipientHost, recipientPort } = httpRequestMessage.getRecipientAddress();
        const metadata = httpRequestMessage.getMessageMetadata();
        const { token } = metadata;
        const { senderHost, senderPort } = httpRequestMessage.getSenderAddress();
        return createMessage({ 
            scopeId: utils.generateGUID(),
            messageStatusCode, Id, data,
            recipientHost, recipientPort, metadata,
            token, senderHost, senderPort
        });
    }});
    Object.defineProperty(this, 'convertHttpResponseMessageToMessage', { configurable: false, writable: false, value: ({ httpResponseMessage }) => {
        const { code } = httpResponseMessage.getMessageStatus();
        const messageStatusCode = code;
        const Id = httpResponseMessage.getId();
        const data = httpResponseMessage.getEncryptedContent();
        const { recipientHost, recipientPort } = httpResponseMessage.getRecipientAddress();
        const metadata = httpResponseMessage.getMessageMetadata();
        const { token } = metadata;
        const { senderHost, senderPort } = httpResponseMessage.getSenderAddress();
        return createMessage({ 
            scopeId: utils.generateGUID(),
            messageStatusCode, Id, data,
            recipientHost, recipientPort, metadata,
            token, senderHost, senderPort
        });
    }});
}
function createMessageConverter({scopeId}) {
    let container = factory.getContainer({ scopeId, type: MessageConverter, variableName:'messageConverter', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: MessageConverter, variableName:'messageConverter', singleton: false });
        container.config({});
            
    }
    container.ensureInstance();
    return container.references;
}
window.createMessageConverter = createMessageConverter;
function MessageMetadata({ metadata, token, senderAddress, recipientAddress }) {
    Object.defineProperty(this, 'create', { configurable: false, writable: false, value: ({ name, value }) => {
        const existingProperty = getProperties({ object: this }).find(p => p.propertyName === name);
        if (!existingProperty) {
            Object.defineProperty(this, name, { configurable: false, get: () => {
                if (isNaN(value)) {
                    return value;
                } else {
                    return Number(value);
                }
            }});
        }
    }});
    this.create({ name: 'token', value: token });
    for(const property of getProperties({ object: metadata })) {
       this.create({ name: property.propertyName, value: property.propertyValue });
    }
    for(const property of getProperties({ object: senderAddress })) {
        this.create({ name: property.propertyName, value: property.propertyValue });
    }
    for(const property of getProperties({ object: recipientAddress })) {
        this.create({ name: property.propertyName, value: property.propertyValue });
    }
}
function createMessageMetadata({scopeId,recipientHost,recipientPort,metadata,token,senderHost,senderPort}) {
    let container = factory.getContainer({ scopeId, type: MessageMetadata, variableName:'messageMetadata', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: MessageMetadata, variableName:'messageMetadata', singleton: false });
        container.config({recipientHost,recipientPort,metadata,token,senderHost,senderPort});
            container.config(createSenderAddress({scopeId,senderHost,senderPort}));
container.config(createRecipientAddress({scopeId,recipientHost,recipientPort}));
    }
    container.ensureInstance();
    return container.references;
}
window.createMessageMetadata = createMessageMetadata;
function MessageQueue({ logger }) {
    const bindings = { };
    const dequeue = async ({ binding }) => {
        if (binding.callbacks.length === 0 || binding.messages.length === 0) {
            return;
        }
        if (binding.locked) {
            log({ logger, binding, text: 'waiting for queue lock' });
            setTimeout(() => dequeue({ binding }), 1000);
            return;
        }
        binding.locked = true;
        const sortedCallbacks = binding.callbacks.sort((x, y) => x.priority - y.priority);
        const callback = sortedCallbacks.shift();
        log({ logger, binding, text: `pulling message (1 of ${binding.messages.length})` });
        const { message } = binding.messages.shift();
        try {
            await callback.resolve({ message });
        } catch(err) {
            log({ logger, binding, text: `callback error: ${ err.message }.` });
        }
        binding.locked = false;
        dequeue({ binding });
    };
    const peek = async ({ binding }) => {
        if (binding.peekCallbacks.length === 0) {
            return;
        }
        if (binding.locked) {
            log({ logger, binding, text: 'waiting for queue lock' });
            setTimeout(() => peek({ binding }), 1000);
            return;
        }
        binding.locked = true;
        log({ logger, binding, text: `peeking at first message (1 of ${binding.messages.length})` });
        const { message } = binding.messages[binding.messages.length-1] || { message: null };
        try {
            const callback = binding.peekCallbacks.shift();
            await callback.resolve({ message });
        } catch(err) {
            log({ logger, binding, text: `callback error: ${err.message}.` });
        }
        binding.locked = false;
        peek({ binding });
    };
    Object.defineProperty(this, 'queueMessage', { configurable: false, writable: false, value: async ({ message, queueName }) => {
        const Id = utils.generateGUID();
        const binding = bindings[queueName];
        log({ logger, binding, text: `pushing message (1 of ${binding.messages.length})` });
        binding.messages.push({ Id, queueName, message });
        peek({ binding });
        dequeue({ binding });
    }});
    Object.defineProperty(this, 'dequeueMessage', { configurable: false, writable: false, value: ({ queueName }) => {
        return new Promise((resolve) => {
            const Id = utils.generateGUID();
            const binding = bindings[queueName];
            const priority = (binding.callbacks.length -1 ) + 1;
            binding.callbacks.push({ Id, queueName, resolve, priority });
            dequeue({ binding });
        });
    }});
    Object.defineProperty(this, 'peekMessage', { configurable: false, writable: false, value: ({ queueName }) => {
        return new Promise((resolve) => {
            const Id = utils.generateGUID();
            const binding = bindings[queueName];
            binding.peekCallbacks.push({ Id, queueName, resolve });
            peek({ binding });
        });
    }});
    Object.defineProperty(this, 'bind', { configurable: false, writable: false, value: ({ scopeId, bindingObj }) => {
        const type = bindingObj.constructor;
        const queueName = `${scopeId}_${type.name}`;
        Object.defineProperty(bindingObj, 'name', { configurable: false, writable: false, value: queueName });
        Object.defineProperty(bindingObj, 'messages', { configurable: false, writable: false, value: [] });
        Object.defineProperty(bindingObj, 'callbacks', { configurable: false, writable: false, value: [] });
        Object.defineProperty(bindingObj, 'peekCallbacks', { configurable: false, writable: false, value: [] });
        Object.defineProperty(bindingObj, 'queueMessage', { configurable: false, writable: true, value: async ({ message }) => {
            await this.queueMessage({ message, queueName });
        }});
        Object.defineProperty(bindingObj, 'dequeueMessage', { configurable: false, writable: true, value: async () => {
            return await this.dequeueMessage({ queueName });
        }});
        Object.defineProperty(bindingObj, 'peekMessage', { configurable: false, writable: true, value: async () => {
            return await this.peekMessage({ queueName });
        }});
        Object.defineProperty(bindingObj, 'unbind', { configurable: false, writable: false, value: () => {
            Object.defineProperty(bindingObj, 'queueMessage', { configurable: false, writable: true, value: () => {
                log({ logger, binding: bindingObj, text: 'unbinded and not queueing messages anymore.' });
            }});
            Object.defineProperty(bindingObj, 'dequeueMessage', { configurable: false, writable: true, value: () => {
                return new Promise(() => {
                    log({ logger, binding: bindingObj, text: 'unbinded and not dequeueing messages anymore.' });
                });
            }});
            Object.defineProperty(bindingObj, 'peekMessage', { configurable: false, writable: true, value: () => {
                return new Promise(() => {
                    log({ logger, binding: bindingObj, text: 'unbinded and not peeking at messages anymore.' });
                });
            }});
            this.unbind({ queueName });
        }});
        bindings[queueName] = bindingObj;
    }});
    Object.defineProperty(this, 'unbind', { configurable: false, writable: false, value: ({ queueName }) => {
        delete bindings[queueName];
    }});
}
function createMessageQueue({scopeId}) {
    let container = factory.getContainer({ scopeId, type: MessageQueue, variableName:'messageQueue', singleton: true });
    if (!container) {
        container = factory.createContainer({ scopeId, type: MessageQueue, variableName:'messageQueue', singleton: true });
        container.config({});
            container.config(createLogger({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createMessageQueue = createMessageQueue;
function MessageStatus({ messageStatusCode }) {
    const messageStatus = allMessageStatus.find(ms => ms.code === messageStatusCode || ms.code === messageStatusCode.toString())
    const { code, description, parent } = messageStatus;
    this.code = code;
    this.description = description;
    this.parent = parent ? new MessageStatus({ messageStatusCode: parent.code }) : null;
    Object.defineProperty(this, 'match', { configurable: false, writable: false, value: ({ wildcard }) => {
        const children = allMessageStatus.filter(ms => ms.parent && ms.parent.code === this.code);
        for(const child of children) {
            if (child.description.toLowerCase().indexOf(wildcard) > -1) {
                return child;
            }
        }
        return null;
    }});
    Object.defineProperty(this, 'root', { configurable: false, writable: false, value: () => {
       if (this.parent === null) {
        return this;
       } else {
         let currentP = this.parent ;
         let prevP = null;
         while(currentP) {
            prevP = currentP;
            currentP = currentP.parent;
         }
         return prevP;
       }
    }});
}
function createMessageStatus({scopeId,messageStatusCode}) {
    let container = factory.getContainer({ scopeId, type: MessageStatus, variableName:'messageStatus', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: MessageStatus, variableName:'messageStatus', singleton: false });
        container.config({messageStatusCode});
            
    }
    container.ensureInstance();
    return container.references;
}
window.createMessageStatus = createMessageStatus;
function MessageStore() {
    Object.defineProperty(this, 'save', { configurable: false, writable: false, value: async ({ message }) => {
    }});
    Object.defineProperty(this, 'get', { configurable: false, writable: false, value: async ({ messageId }) => {
    }});
}
function createMessageStore({scopeId}) {
    let container = factory.getContainer({ scopeId, type: MessageStore, variableName:'messageStore', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: MessageStore, variableName:'messageStore', singleton: false });
        container.config({});
            
    }
    container.ensureInstance();
    return container.references;
}
window.createMessageStore = createMessageStore;
function RecipientAddress({ recipientHost, recipientPort }) {
    Object.defineProperty(this, 'recipientHost', { configurable: false, writable: false, value: recipientHost });
    Object.defineProperty(this, 'recipientPort', { configurable: false, writable: false, value: recipientPort });
}
function createRecipientAddress({scopeId,recipientHost,recipientPort}) {
    let container = factory.getContainer({ scopeId, type: RecipientAddress, variableName:'recipientAddress', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: RecipientAddress, variableName:'recipientAddress', singleton: false });
        container.config({recipientHost,recipientPort});
            
    }
    container.ensureInstance();
    return container.references;
}
window.createRecipientAddress = createRecipientAddress;
function SenderAddress({ senderHost, senderPort }) {
    Object.defineProperty(this, 'senderHost', { configurable: false, writable: false, value: senderHost });
    Object.defineProperty(this, 'senderPort', { configurable: false, writable: false, value: senderPort });
}
function createSenderAddress({scopeId,senderHost,senderPort}) {
    let container = factory.getContainer({ scopeId, type: SenderAddress, variableName:'senderAddress', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: SenderAddress, variableName:'senderAddress', singleton: false });
        container.config({senderHost,senderPort});
            
    }
    container.ensureInstance();
    return container.references;
}
window.createSenderAddress = createSenderAddress;
function ServerMessageBus({ httpServerResponseMessageBus, httpServerRequestMessageBus, messageConverter }) {
    Object.defineProperty(this, 'publish', { configurable: false, writable: false, value: async ({ message }) => {
        await httpServerResponseMessageBus.publish(messageConverter.convertMessageToHttpResponseMessage({ message }));
    }});
    Object.defineProperty(this, 'subscribe', { configurable: false, writable: false, value: ({ callback }) => {
        httpServerRequestMessageBus.subscribe({ callback: async ({ httpRequestMessage }) => {
            await callback(messageConverter.convertHttpRequestMessageToMessage({ httpRequestMessage }));
        }});
    }});
}
function createServerMessageBus({scopeId}) {
    let container = factory.getContainer({ scopeId, type: ServerMessageBus, variableName:'serverMessageBus', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: ServerMessageBus, variableName:'serverMessageBus', singleton: false });
        container.config({});
            container.config(createHttpServerRequestMessageBus({scopeId}));
container.config(createHttpServerResponseMessageBus({scopeId}));
container.config(createMessageConverter({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createServerMessageBus = createServerMessageBus;
function UserSecurity({ userId }) {

    let _remoteBase64RSAPublicKey = null;
    let base64RSAPrivateKey;
    let base64RSAPublicKey;
    let user = userIdentities[userId];
    let authToken = null;
  
    Object.defineProperty(this, 'isRegistered', { configurable: false, writable: false, value: () => {
        return user !== undefined;
    }});

    Object.defineProperty(this, 'authenticate', { configurable: false, writable: false, value: ({ secret, remoteBase64RSAPublickey }) => {
        authToken = null;
        const { hashedPassphrase } = utils.hashPassphrase(secret,  user.hashedPassphraseSalt);
        if (hashedPassphrase === user.hashedPassphrase) {
            const { privateKey, publicKey } = utils.generatePublicPrivateKeys(hashedPassphrase);
            base64RSAPrivateKey = utils.stringToBase64(privateKey);
            base64RSAPublicKey = utils.stringToBase64(publicKey);
            if (remoteBase64RSAPublickey) {
                _remoteBase64RSAPublicKey = remoteBase64RSAPublickey
            } else {
                _remoteBase64RSAPublicKey = base64RSAPublicKey;
            }
            authToken = utils.stringToBase64(utils.getJSONString({ userId, base64RSAPublicKey }));
            return { token: authToken };
        }
        return false;
    }});
    Object.defineProperty(this, 'isAuthorised', { configurable: false, writable: false, value: ({ token }) => {
        return utils.isBase64String(base64RSAPrivateKey) && utils.isBase64String(base64RSAPublicKey) && authToken === token;
    }});
    Object.defineProperty(this, 'register', { configurable: false, writable: false, value: ({ secret }) => {
        const { hashedPassphrase, hashedPassphraseSalt } = utils.hashPassphrase(secret);
        user = { hashedPassphrase, hashedPassphraseSalt };
        userIdentities[userId] = user;
        fs.writeFileSync(userIdentitiesStorePath, JSON.stringify(userIdentities), 'utf8');
    }});
    Object.defineProperty(this, 'unregister', { configurable: false, writable: false, value: () => {
        delete userIdentities[userId];
        fs.writeFileSync(userIdentitiesStorePath, JSON.stringify(userIdentities), 'utf8');
    }});
    Object.defineProperty(this, 'getHashedPassphrase', { configurable: false, writable: false, value: () => {
        return user.hashedPassphrase;
    }});
    Object.defineProperty(this, 'getUserId', { configurable: false, writable: false, value: () => {
        return userId;
    }});
    Object.defineProperty(this, 'getBase64PublicKey', { configurable: false, writable: false, value: () => {
        return { base64RSAPublicKey };
    }});
    Object.defineProperty(this, 'getPublicKey', { configurable: false, writable: false, value: () => {
        return { publicKey: utils.base64ToString(base64RSAPublicKey) };
    }});
    Object.defineProperty(this, 'getToken', { configurable: false, writable: false, value: () => {
        return { token: authToken };
    }});
    Object.defineProperty(this, 'encryptObjectToJSON', { configurable: false, writable: false, value: ({ object }) => {
        const jsonStr = utils.getJSONString(object) || '{}';
        return utils.encryptToBase64Str(jsonStr, utils.base64ToString(_remoteBase64RSAPublicKey));
    }});
    Object.defineProperty(this, 'decryptJSONToObject', { configurable: false, writable: false, value: ({ encryptedJsonStr }) => {
        const hashedPassphrase = this.getHashedPassphrase();
        const privateKey = utils.base64ToString(base64RSAPrivateKey);
        return utils.getJSONObject(utils.decryptFromBase64Str(encryptedJsonStr, privateKey, hashedPassphrase));
    }});
}
function createUserSecurity({scopeId,userId}) {
    let container = factory.getContainer({ scopeId, type: UserSecurity, variableName:'userSecurity', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: UserSecurity, variableName:'userSecurity', singleton: false });
        container.config({userId});
            
    }
    container.ensureInstance();
    return container.references;
}
window.createUserSecurity = createUserSecurity;
function UserSessions({ scopeId }) {
    const sessions = {};
    const { createUserSecurity } = require('./factory/usersecurity.factory.js');
    Object.defineProperty(this, 'ensureSession', { configurable: false, writable: false, value: ({ userId }) => {
        if (!sessions[userId]) {
            const { userSecurity } = createUserSecurity({ scopeId, userId });
            sessions[userId] = userSecurity;
        }
        return { userSecurity: sessions[userId] };
    }});
}
function createUserSessions({scopeId}) {
    let container = factory.getContainer({ scopeId, type: UserSessions, variableName:'userSessions', singleton: true });
    if (!container) {
        container = factory.createContainer({ scopeId, type: UserSessions, variableName:'userSessions', singleton: true });
        container.config({});
            
    }
    container.ensureInstance();
    return container.references;
}
window.createUserSessions = createUserSessions;
function HttpClientMessageBus({ scopeId, httpClientRequestMessageQueueBinding, httpClientResponseMessageQueueBinding, httpClientStartMessageQueueBinding, httpClientStartedMessageQueueBinding, httpClientStopMessageQueueBinding, httpClientStoppedMessageQueueBinding, timeout }) {

    const dequeueRequestMessage = async ({ callback }) => {
        const { message } = await httpClientRequestMessageQueueBinding.dequeueMessage();
        await callback({ message });
        await dequeueRequestMessage({ callback });
    };
    
    httpClientStopMessageQueueBinding.dequeueMessage().then(({ message }) => {
        if (message.scopeId !== scopeId) {
            httpClientStopMessageQueueBinding.queueMessage({ message });
        } else {
            httpClientRequestMessageQueueBinding.unbind();
            httpClientResponseMessageQueueBinding.unbind();
        }
    });

    httpClientStartMessageQueueBinding.dequeueMessage().then( async () => {
        httpClientStartedMessageQueueBinding.queueMessage({ message: { scopeId } });
        dequeueRequestMessage({ callback: ({ message }) => {
            const httpRequestMessage = message;
            const { recipientHost, recipientPort } = httpRequestMessage.getRecipientAddress();
            const path = httpRequestMessage.getPath();
            const headers = httpRequestMessage.getHeaders();
            const method = httpRequestMessage.getMethod();
            const data = httpRequestMessage.getEncryptedContent();
            const httpRequest = http.request({host: recipientHost, port: recipientPort, path, headers, method });
            httpRequest.setTimeout(timeout);
            httpRequest.on('response', async (httpResponse) => {
                httpResponse.setEncoding('utf8');
                httpResponse.on('error', (error) => console.error(error));
                httpResponse.body = '';
                for await (const chunk of httpResponse) {
                    httpResponse.body += chunk
                }
                await httpClientResponseMessageQueueBinding.queueMessage({ message: httpResponse });
            });
            httpRequest.on('error', (error) => console.error(error));
            httpRequest.end(data);
        }});
    });
}
function createHttpClientMessageBus({scopeId,timeout}) {
    let container = factory.getContainer({ scopeId, type: HttpClientMessageBus, variableName:'httpClientMessageBus', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpClientMessageBus, variableName:'httpClientMessageBus', singleton: false });
        container.config({timeout});
            container.config(createHttpClientStoppedMessageQueueBinding({scopeId}));
container.config(createHttpClientStopMessageQueueBinding({scopeId}));
container.config(createHttpClientStartedMessageQueueBinding({scopeId}));
container.config(createHttpClientStartMessageQueueBinding({scopeId}));
container.config(createHttpClientResponseMessageQueueBinding({scopeId}));
container.config(createHttpClientRequestMessageQueueBinding({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpClientMessageBus = createHttpClientMessageBus;
function HttpClientMessageBusManager({ scopeId, httpClientRequestMessageQueueBinding, httpClientResponseMessageQueueBinding, httpClientStartMessageQueueBinding, httpClientStartedMessageQueueBinding, httpClientStopMessageQueueBinding, httpClientStoppedMessageQueueBinding }) {
    httpClientStartedMessageQueueBinding.peekMessage().then(({ message }) => {
        if (message) {
            httpClientStopMessageQueueBinding.queueMessage({ message: { scopeId: message.scopeId } });
            httpClientStartMessageQueueBinding.queueMessage({ message: { scopeId } });
        } else {
            httpClientStartMessageQueueBinding.queueMessage({ message: { scopeId } });
        }
    });
}
function createHttpClientMessageBusManager({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpClientMessageBusManager, variableName:'httpClientMessageBusManager', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpClientMessageBusManager, variableName:'httpClientMessageBusManager', singleton: false });
        container.config({});
            container.config(createHttpClientStopMessageQueueBinding({scopeId}));
container.config(createHttpClientStartedMessageQueueBinding({scopeId}));
container.config(createHttpClientStartMessageQueueBinding({scopeId}));
container.config(createHttpClientResponseMessageQueueBinding({scopeId}));
container.config(createHttpClientRequestMessageQueueBinding({scopeId}));
container.config(createHttpClientStoppedMessageQueueBinding({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpClientMessageBusManager = createHttpClientMessageBusManager;
function HttpClientRequestMessageBus({ httpClientRequestMessageQueueBinding }) {
    Object.defineProperty(this, 'publish', { configurable: false, writable: false, value: ({ httpRequestMessage }) => {
        httpClientRequestMessageQueueBinding.queueMessage({ message: httpRequestMessage });
    }});
}
function createHttpClientRequestMessageBus({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpClientRequestMessageBus, variableName:'httpClientRequestMessageBus', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpClientRequestMessageBus, variableName:'httpClientRequestMessageBus', singleton: false });
        container.config({});
            container.config(createHttpClientRequestMessageQueueBinding({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpClientRequestMessageBus = createHttpClientRequestMessageBus;
function HttpClientRequestMessageQueueBinding({ scopeId, messageQueue }) {
    messageQueue.bind({ bindingObj: this, scopeId });
}
function createHttpClientRequestMessageQueueBinding({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpClientRequestMessageQueueBinding, variableName:'httpClientRequestMessageQueueBinding', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpClientRequestMessageQueueBinding, variableName:'httpClientRequestMessageQueueBinding', singleton: false });
        container.config({});
            container.config(createMessageQueue({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpClientRequestMessageQueueBinding = createHttpClientRequestMessageQueueBinding;
function HttpClientResponseMessageBus({ httpClientResponseMessageQueueBinding }) {
    const { createHttpResponseMessage } = require('../factory/httpresponsemessage.factory');
    Object.defineProperty(this, 'subscribe', { configurable: false, writable: false, value: ({ callback }) => {
        httpClientResponseMessageQueueBinding.dequeueMessage().then( async ({ message }) => {
            const httpResponse = message;
            const { body, statusCode, headers } = httpResponse;
            const messageStatusCode = statusCode;
            const { recipienthost, recipientport, senderhost, senderport, token } = headers;
            await callback(createHttpResponseMessage({
                scopeId: utils.generateGUID(),
                messageStatusCode, Id: null, data: body,
                recipientHost: recipienthost, recipientPort: recipientport, 
                metadata: headers, token,
                senderHost: senderhost, senderPort: senderport,
            }));
            this.subscribe({ callback });
        });
    }});
}
function createHttpClientResponseMessageBus({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpClientResponseMessageBus, variableName:'httpClientResponseMessageBus', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpClientResponseMessageBus, variableName:'httpClientResponseMessageBus', singleton: false });
        container.config({});
            container.config(createHttpClientResponseMessageQueueBinding({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpClientResponseMessageBus = createHttpClientResponseMessageBus;
function HttpClientResponseMessageQueueBinding({ scopeId, messageQueue }) {
    messageQueue.bind({ bindingObj: this, scopeId });
}
function createHttpClientResponseMessageQueueBinding({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpClientResponseMessageQueueBinding, variableName:'httpClientResponseMessageQueueBinding', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpClientResponseMessageQueueBinding, variableName:'httpClientResponseMessageQueueBinding', singleton: false });
        container.config({});
            container.config(createMessageQueue({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpClientResponseMessageQueueBinding = createHttpClientResponseMessageQueueBinding;
function HttpClientStartedMessageQueueBinding({ scopeId, messageQueue }) {
    messageQueue.bind({ bindingObj: this, scopeId });
}
function createHttpClientStartedMessageQueueBinding({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpClientStartedMessageQueueBinding, variableName:'httpClientStartedMessageQueueBinding', singleton: true });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpClientStartedMessageQueueBinding, variableName:'httpClientStartedMessageQueueBinding', singleton: true });
        container.config({});
            container.config(createMessageQueue({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpClientStartedMessageQueueBinding = createHttpClientStartedMessageQueueBinding;
function HttpClientStartMessageQueueBinding({ scopeId, messageQueue }) {
    messageQueue.bind({ bindingObj: this, scopeId });
}
function createHttpClientStartMessageQueueBinding({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpClientStartMessageQueueBinding, variableName:'httpClientStartMessageQueueBinding', singleton: true });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpClientStartMessageQueueBinding, variableName:'httpClientStartMessageQueueBinding', singleton: true });
        container.config({});
            container.config(createMessageQueue({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpClientStartMessageQueueBinding = createHttpClientStartMessageQueueBinding;
function HttpClientStopMessageQueueBinding({ scopeId, messageQueue }) {
    messageQueue.bind({ bindingObj: this, scopeId });
}
function createHttpClientStopMessageQueueBinding({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpClientStopMessageQueueBinding, variableName:'httpClientStopMessageQueueBinding', singleton: true });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpClientStopMessageQueueBinding, variableName:'httpClientStopMessageQueueBinding', singleton: true });
        container.config({});
            container.config(createMessageQueue({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpClientStopMessageQueueBinding = createHttpClientStopMessageQueueBinding;
function HttpClientStoppedMessageQueueBinding({ scopeId, messageQueue }) {
    messageQueue.bind({ bindingObj: this, scopeId });
}
function createHttpClientStoppedMessageQueueBinding({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpClientStoppedMessageQueueBinding, variableName:'httpClientStoppedMessageQueueBinding', singleton: true });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpClientStoppedMessageQueueBinding, variableName:'httpClientStoppedMessageQueueBinding', singleton: true });
        container.config({});
            container.config(createMessageQueue({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpClientStoppedMessageQueueBinding = createHttpClientStoppedMessageQueueBinding;
function HttpRequestMessage({ message }) {
    const { senderHost, senderPort } = message.getSenderAddress();
    const { recipientHost, recipientPort } = message.getRecipientAddress();
    const { path, secret, token } = message.getMessageMetadata();
    const { contentType, contentLength } = message.getContentMetadata();
    const headers = { 
        'Content-Type': contentType.description,
        'Content-Length': contentLength,
        secret, token,
        senderhost: senderHost, senderport: senderPort,
        recipienthost: recipientHost, recipientport: recipientPort
    };
    Object.defineProperty(this, 'getId', { configurable: false, writable: false, value: message.getId });
    Object.defineProperty(this, 'getEncryptedContent', { configurable: false, writable: false, value: message.getEncryptedContent });
    Object.defineProperty(this, 'getDecryptedContent', { configurable: false, writable: false, value: message.getDecryptedContent });
    Object.defineProperty(this, 'getSenderAddress', { configurable: false, writable: false, value:message.getSenderAddress });
    Object.defineProperty(this, 'getRecipientAddress', { configurable: false, writable: false, value:  message.getRecipientAddress });
    Object.defineProperty(this, 'getContentMetadata', { configurable: false, writable: false, value:  message.getContentMetadata });
    Object.defineProperty(this, 'getMessageMetadata', { configurable: false, writable: false, value:  message.getMessageMetadata });
    Object.defineProperty(this, 'getHeaders', { configurable: false, writable: false, value: () => {
        return utils.getJSONObject(utils.getJSONString(headers)); //clone
    }});
    Object.defineProperty(this, 'getPath', { configurable: false, writable: false, value: () => {
        return path;
    }});
    Object.defineProperty(this, 'getMethod', { configurable: false, writable: false, value: () => {
        return "POST";
    }});
    Object.defineProperty(this, 'getMessageStatus', { configurable: false, writable: false, value: () => {
        const status = message.getMessageStatus();
        const httpStatus = status.match({ wildcard: 'http'});
        return httpStatus;
    }});
}
function createHttpRequestMessage({scopeId,messageStatusCode,Id,data,recipientHost,recipientPort,metadata,token,senderHost,senderPort}) {
    let container = factory.getContainer({ scopeId, type: HttpRequestMessage, variableName:'httpRequestMessage', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpRequestMessage, variableName:'httpRequestMessage', singleton: false });
        container.config({messageStatusCode,Id,data,recipientHost,recipientPort,metadata,token,senderHost,senderPort});
            container.config(createMessage({scopeId,messageStatusCode,Id,data,recipientHost,recipientPort,metadata,token,senderHost,senderPort}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpRequestMessage = createHttpRequestMessage;
function HttpResponseMessage({ message }) {
    const { senderHost, senderPort } = message.getSenderAddress();
    const { recipientHost, recipientPort } = message.getRecipientAddress();
    const { token } = message.getMessageMetadata();
    const { contentType, contentLength } = message.getContentMetadata();
    const headers = {
        'Content-Type': contentType.description,
        'Content-Length': contentLength,
        senderhost: senderHost, senderport: senderPort,
        recipienthost: recipientHost, recipientport: recipientPort,
        token
    };
    Object.defineProperty(this, 'getId', { configurable: false, writable: false, value: message.getId });
    Object.defineProperty(this, 'getEncryptedContent', { configurable: false, writable: false, value: message.getEncryptedContent });
    Object.defineProperty(this, 'getDecryptedContent', { configurable: false, writable: false, value: message.getDecryptedContent });
    Object.defineProperty(this, 'getSenderAddress', { configurable: false, writable: false, value:message.getSenderAddress });
    Object.defineProperty(this, 'getRecipientAddress', { configurable: false, writable: false, value: message.getRecipientAddress });
    Object.defineProperty(this, 'getContentMetadata', { configurable: false, writable: false, value:  message.getContentMetadata });
    Object.defineProperty(this, 'getMessageMetadata', { configurable: false, writable: false, value:  message.getMessageMetadata });
    Object.defineProperty(this, 'getMessageStatus', { configurable: false, writable: false, value:  message.getMessageStatus });
    Object.defineProperty(this, 'getHeaders', { configurable: false, writable: false, value: () => {
        return utils.getJSONObject(utils.getJSONString(headers)); //clone
    }});
    Object.defineProperty(this, 'getStatusCode', { configurable: false, writable: false, value: () => {
        const status = message.getMessageStatus();
        const { code } = status.match({ wildcard: 'http'});
        return code;
    }});
    Object.defineProperty(this, 'getStatusMessage', { configurable: false, writable: false, value: () => {
        const status = message.getMessageStatus();
        const { description } = status.match({ wildcard: 'http'});
        return description ;
    }});
}
function createHttpResponseMessage({scopeId,messageStatusCode,Id,data,recipientHost,recipientPort,metadata,token,senderHost,senderPort}) {
    let container = factory.getContainer({ scopeId, type: HttpResponseMessage, variableName:'httpResponseMessage', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpResponseMessage, variableName:'httpResponseMessage', singleton: false });
        container.config({messageStatusCode,Id,data,recipientHost,recipientPort,metadata,token,senderHost,senderPort});
            container.config(createMessage({scopeId,messageStatusCode,Id,data,recipientHost,recipientPort,metadata,token,senderHost,senderPort}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpResponseMessage = createHttpResponseMessage;
function HttpServerMessageBus({ scopeId, httpServerRequestMessageQueueBinding, httpServerResponseMessageQueueBinding, httpServerStartMessageQueueBinding, httpServerStartedMessageQueueBinding, httpServerStopMessageQueueBinding, httpServerStoppedMessageQueueBinding, senderAddress, logger, timeout }) {
    httpServerStartMessageQueueBinding.dequeueMessage().then(() => {
        const { senderHost, senderPort } = senderAddress;
        const options = { host: senderHost, port: senderPort };
        const server = http.createServer();
        server.on("error", (error) => {
            if (options.host) {
                dns.lookup(options.host, (dnsErr) => {
                    if (dnsErr) {
                        logger.log({ date: new Date(), context: 'HttpServer', text: dnsErr.message });
                    } else {
                        logger.log({ date: new Date(), context: 'HttpServer', text: error.message });
                    }
                });
            } else {
                logger.log({ date: new Date(), context: 'HttpServer', text: 'host not specified' });
            }
        });
        server.on("request", async (httpRequest, httpResponse) => {
            httpRequest.setTimeout(timeout);
            httpRequest.on('error', (error) => console.error(error));
            httpRequest.body = '';
            for await (const chunk of httpRequest) {
                httpRequest.body += chunk
            }
            await httpServerRequestMessageQueueBinding.queueMessage({ message: httpRequest });
            const { message } = await httpServerResponseMessageQueueBinding.dequeueMessage();
            httpResponse.writeHead(
                message.getStatusCode(),
                message.getStatusMessage(),
                message.getHeaders()
            ).end(message.getEncryptedContent());
        });
        server.on("listening", () => {
            logger.log({ date: new Date(), context:'HttpServer', text:`listening on: ${ utils.getJSONString(options) }` });
            httpServerStartedMessageQueueBinding.queueMessage({ message: { scopeId } });
        });
        server.on('close', () => {
            logger.log({ date: new Date(), context: 'HttpServer', text: 'server was stopped' });
            httpServerRequestMessageQueueBinding.unbind();
            httpServerResponseMessageQueueBinding.unbind();
            httpServerStoppedMessageQueueBinding.queueMessage({ message: { scopeId } });
        });
        httpServerStopMessageQueueBinding.dequeueMessage().then(() => {
            server.close();
        });
        server.listen(options);
    });
}
function createHttpServerMessageBus({scopeId,timeout,senderHost,senderPort}) {
    let container = factory.getContainer({ scopeId, type: HttpServerMessageBus, variableName:'httpServerMessageBus', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpServerMessageBus, variableName:'httpServerMessageBus', singleton: false });
        container.config({timeout,senderHost,senderPort});
            container.config(createLogger({scopeId}));
container.config(createSenderAddress({scopeId,senderHost,senderPort}));
container.config(createHttpServerStoppedMessageQueueBinding({scopeId}));
container.config(createHttpServerStopMessageQueueBinding({scopeId}));
container.config(createHttpServerStartedMessageQueueBinding({scopeId}));
container.config(createHttpServerStartMessageQueueBinding({scopeId}));
container.config(createHttpServerResponseMessageQueueBinding({scopeId}));
container.config(createHttpServerRequestMessageQueueBinding({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpServerMessageBus = createHttpServerMessageBus;
function HttpServerMessageBusManager({ scopeId, httpServerRequestMessageQueueBinding, httpServerResponseMessageQueueBinding, httpServerStartMessageQueueBinding, httpServerStartedMessageQueueBinding, httpServerStopMessageQueueBinding, httpServerStoppedMessageQueueBinding }) {
    httpServerStartedMessageQueueBinding.peekMessage().then(({ message }) => {
        if (message) {
            const _message = message;
            httpServerStopMessageQueueBinding.queueMessage({ message: { scopeId: _message.scopeId } });
            httpServerStoppedMessageQueueBinding.dequeueMessage().then(({ message }) => {
                if (scopeId !== message.scopeId && _message.scopeId === message.scopeId) {
                    httpServerStartMessageQueueBinding.queueMessage({ message: { scopeId } });
                }
            });
        } else {
            httpServerStartMessageQueueBinding.queueMessage({ message: { scopeId } });
        }
    });
}
function createHttpServerMessageBusManager({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpServerMessageBusManager, variableName:'httpServerMessageBusManager', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpServerMessageBusManager, variableName:'httpServerMessageBusManager', singleton: false });
        container.config({});
            container.config(createHttpServerStopMessageQueueBinding({scopeId}));
container.config(createHttpServerStartedMessageQueueBinding({scopeId}));
container.config(createHttpServerStartMessageQueueBinding({scopeId}));
container.config(createHttpServerResponseMessageQueueBinding({scopeId}));
container.config(createHttpServerRequestMessageQueueBinding({scopeId}));
container.config(createHttpServerStoppedMessageQueueBinding({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpServerMessageBusManager = createHttpServerMessageBusManager;
function HttpServerRequestMessageBus({ httpServerRequestMessageQueueBinding }) {
    const { createHttpRequestMessage } = require('../factory/httprequestmessage.factory');
    Object.defineProperty(this, 'subscribe', { configurable: false, writable: false, value: ({ callback }) => {
        httpServerRequestMessageQueueBinding.dequeueMessage().then( async ({ message }) => {
            const httpRequest = message;
            const { headers, body, path } = httpRequest;
            const metadata = headers;
            let { recipienthost, recipientport, senderhost, senderport, token } = metadata;
            recipientport = isNaN(recipientport) ? recipientport : Number(recipientport);
            senderport = isNaN(senderport) ? senderport : Number(senderport);
            metadata['recipientport'] = recipientport;
            metadata['senderport'] = senderport;
            metadata.path = path;
            const messageStatusCode = 2;
            await callback(createHttpRequestMessage({ 
                scopeId: utils.generateGUID(),
                messageStatusCode, Id: null, data: body,
                recipientHost: recipienthost, recipientPort: recipientport,
                metadata, token, senderHost: senderhost, senderPort: senderport
            }));
            this.subscribe({ callback });
        });
    }});
}
function createHttpServerRequestMessageBus({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpServerRequestMessageBus, variableName:'httpServerRequestMessageBus', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpServerRequestMessageBus, variableName:'httpServerRequestMessageBus', singleton: false });
        container.config({});
            container.config(createHttpServerRequestMessageQueueBinding({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpServerRequestMessageBus = createHttpServerRequestMessageBus;
function HttpServerRequestMessageQueueBinding({ scopeId, messageQueue }) {
    messageQueue.bind({ bindingObj: this, scopeId });
}
function createHttpServerRequestMessageQueueBinding({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpServerRequestMessageQueueBinding, variableName:'httpServerRequestMessageQueueBinding', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpServerRequestMessageQueueBinding, variableName:'httpServerRequestMessageQueueBinding', singleton: false });
        container.config({});
            container.config(createMessageQueue({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpServerRequestMessageQueueBinding = createHttpServerRequestMessageQueueBinding;
function HttpServerResponseMessageBus({ httpServerResponseMessageQueueBinding }) {
    Object.defineProperty(this, 'publish', { configurable: false, writable: false, value: async ({ httpResponseMessage }) => {
        await httpServerResponseMessageQueueBinding.queueMessage({ message: httpResponseMessage });
    }});
}
function createHttpServerResponseMessageBus({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpServerResponseMessageBus, variableName:'httpServerResponseMessageBus', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpServerResponseMessageBus, variableName:'httpServerResponseMessageBus', singleton: false });
        container.config({});
            container.config(createHttpServerResponseMessageQueueBinding({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpServerResponseMessageBus = createHttpServerResponseMessageBus;
function HttpServerResponseMessageQueueBinding({ scopeId, messageQueue }) {
    messageQueue.bind({ bindingObj: this, scopeId });
}
function createHttpServerResponseMessageQueueBinding({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpServerResponseMessageQueueBinding, variableName:'httpServerResponseMessageQueueBinding', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpServerResponseMessageQueueBinding, variableName:'httpServerResponseMessageQueueBinding', singleton: false });
        container.config({});
            container.config(createMessageQueue({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpServerResponseMessageQueueBinding = createHttpServerResponseMessageQueueBinding;
function HttpServerStartedMessageQueueBinding({ scopeId, messageQueue }) {
    messageQueue.bind({ bindingObj: this, scopeId });
}
function createHttpServerStartedMessageQueueBinding({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpServerStartedMessageQueueBinding, variableName:'httpServerStartedMessageQueueBinding', singleton: true });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpServerStartedMessageQueueBinding, variableName:'httpServerStartedMessageQueueBinding', singleton: true });
        container.config({});
            container.config(createMessageQueue({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpServerStartedMessageQueueBinding = createHttpServerStartedMessageQueueBinding;
function HttpServerStartMessageQueueBinding({ scopeId, messageQueue }) {
    messageQueue.bind({ bindingObj: this, scopeId });
}
function createHttpServerStartMessageQueueBinding({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpServerStartMessageQueueBinding, variableName:'httpServerStartMessageQueueBinding', singleton: true });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpServerStartMessageQueueBinding, variableName:'httpServerStartMessageQueueBinding', singleton: true });
        container.config({});
            container.config(createMessageQueue({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpServerStartMessageQueueBinding = createHttpServerStartMessageQueueBinding;
function HttpServerStopMessageQueueBinding({ scopeId, messageQueue }) {
    messageQueue.bind({ bindingObj: this, scopeId });
}
function createHttpServerStopMessageQueueBinding({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpServerStopMessageQueueBinding, variableName:'httpServerStopMessageQueueBinding', singleton: true });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpServerStopMessageQueueBinding, variableName:'httpServerStopMessageQueueBinding', singleton: true });
        container.config({});
            container.config(createMessageQueue({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpServerStopMessageQueueBinding = createHttpServerStopMessageQueueBinding;
function HttpServerStoppedMessageQueueBinding({ scopeId, messageQueue }) {
    messageQueue.bind({ bindingObj: this, scopeId });
}
function createHttpServerStoppedMessageQueueBinding({scopeId}) {
    let container = factory.getContainer({ scopeId, type: HttpServerStoppedMessageQueueBinding, variableName:'httpServerStoppedMessageQueueBinding', singleton: true });
    if (!container) {
        container = factory.createContainer({ scopeId, type: HttpServerStoppedMessageQueueBinding, variableName:'httpServerStoppedMessageQueueBinding', singleton: true });
        container.config({});
            container.config(createMessageQueue({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createHttpServerStoppedMessageQueueBinding = createHttpServerStoppedMessageQueueBinding;
function WebSocketConnection({ websocketMessageQueue, hostAddress, timeout }) {
}
function createWebSocketConnection({scopeId,timeout,hostAddress}) {
    let container = factory.getContainer({ scopeId, type: WebSocketConnection, variableName:'webSocketConnection', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: WebSocketConnection, variableName:'webSocketConnection', singleton: false });
        container.config({timeout,hostAddress});
            container.config(createWebSocketMessageQueue({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createWebSocketConnection = createWebSocketConnection;
function WebSocketMessageHandler({ websocketMessageQueue }) {
    this.Id = utils.generateGUID();
}
function createWebSocketMessageHandler({scopeId}) {
    let container = factory.getContainer({ scopeId, type: WebSocketMessageHandler, variableName:'webSocketMessageHandler', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: WebSocketMessageHandler, variableName:'webSocketMessageHandler', singleton: false });
        container.config({});
            container.config(createWebSocketMessageQueue({scopeId}));
    }
    container.ensureInstance();
    return container.references;
}
window.createWebSocketMessageHandler = createWebSocketMessageHandler;
function WebSocketMessageQueue() {
}
function createWebSocketMessageQueue({scopeId}) {
    let container = factory.getContainer({ scopeId, type: WebSocketMessageQueue, variableName:'websocketMessageQueue', singleton: false });
    if (!container) {
        container = factory.createContainer({ scopeId, type: WebSocketMessageQueue, variableName:'websocketMessageQueue', singleton: false });
        container.config({});
            
    }
    container.ensureInstance();
    return container.references;
}
window.createWebSocketMessageQueue = createWebSocketMessageQueue;
